from matplotlib import patches
from matplotlib.backends.backend_qt import NavigationToolbar2QT
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg
from matplotlib.figure import Figure
from contour import Contour
from annotation import ContourAnnotation


class Canvas(FigureCanvasQTAgg):
    """
    Class that extends FigureCanvasQTAgg (a backend class provided by matplotlib for Qt integration).

    The base class is extended to allow for handling of events (like drawing, which requires a mouseMove event) and
    make use of the builtin toolbar that Qt provides without having to display it to the user.
    """
    def __init__(self, fig: Figure):
        """Class initialization"""
        super(Canvas, self).__init__(fig)
        self.toolbar: NavigationToolbar2QT = None
        self.drawing = False
        self.contour: Contour = None
        self.annotation: ContourAnnotation = None
        self.cid = fig.canvas.mpl_connect('motion_notify_event', self.contour_draw)

    def set_toolbar(self, toolbar: NavigationToolbar2QT):
        """This function sets which toolbar is responsible for this Canvas."""
        self.toolbar = toolbar
        self.toolbar.hide()
        self.toolbar.pan()

    def wheelEvent(self, event):
        """
        This function handles wheelEvent generate by Qt, which occurs when a mouse wheel is scrolled

        Zooms the layer in if the wheel is scrolled away from the user and zooms out if the wheel is scrolled towards
        the user.
        """
        ax = self.figure.get_axes()[0]
        ax.use_stick_edges = False
        xmin, xmax = ax.get_xlim()
        ymin, ymax = ax.get_ylim()
        scale = (xmax - xmin) / (ymax - ymin)
        if event.angleDelta().y() > 0:
            ax.set_xlim(xmin + 1.5 * scale, xmax - 1.5 * scale, auto=False)
            ax.set_ylim(ymin + 1.5, ymax - 1.5)
        else:
            ax.set_xlim(xmin - 1.5 * scale, xmax + 1.5 * scale, auto=False)
            ax.set_ylim(ymin - 1.5, ymax + 1.5)
        self.figure.canvas.draw()

    def contour_draw(self, event):
        """
        This function is defined for handling the mouseMove event generated by matplotlib

        If the user is simultaneously pressing the main (by default left) mouse button and the Draw button was pressed
        beforehand it starts applying small circular patches on to the layer. Given the frequency of these checks
        it creates the effect of drawing on the layer.
        """
        if event.button == 1:
            if self.drawing:
                parent_ax = self.figure.get_axes()[0]
                point = patches.Circle((event.xdata, event.ydata))
                try:
                    self.contour.pointList.append((event.xdata, event.ydata))
                except:
                    print("Drawing out of bounds")
                parent_ax.add_patch(point)
                self.figure.canvas.draw()

    def draw_toggle(self):
        """This function is used by the Draw button - toggles the drawing bool used by contour_draw() function."""
        if not self.drawing:
            self.drawing = True
        else:
            self.drawing = False
        self.toolbar.pan()

    def redraw_contour(self):
        """
        This function is used when a slider is moved and the Canvas has found a contour for this layer - this
        redraws all the patches made by the user.
        """
        parent_ax = self.figure.get_axes()[0]
        for coord in self.contour.pointList:
            point = patches.Circle((coord[0], coord[1]))
            parent_ax.add_patch(point)
        self.figure.canvas.draw()

    def clear_contour(self):
        """This function clears the currently displayed patches - called when the user is changing the layer."""
        parent_ax = self.figure.get_axes()[0]
        for patch in parent_ax.patches:
            patch.remove()
